// Code generated by girgen. DO NOT EDIT.

package gi

/*
#cgo pkg-config: girepository-2.0
#include <girepository/girepository.h>
*/
import "C"

import (
	"strings"
	"structs"
	"unsafe"

	"deedles.dev/gir/g"
)

var TypeArgInfo = g.Type[ArgInfo](C.gi_arg_info_get_type())

type ArgInfo struct {
	_ structs.HostLayout
	BaseInfo
	_ [48]byte
}

func (obj *ArgInfo) c() *C.GIArgInfo {
	return (*C.GIArgInfo)(unsafe.Pointer(obj))
}

func (obj *ArgInfo) AsGIArgInfo() *ArgInfo {
	return obj
}

func (s *ArgInfo) GetClosureIndex() (out_closure_index uint32, r bool) {
	var arg0 C.uint
	cr := C.gi_arg_info_get_closure_index(s.c(), &arg0)
	out_closure_index = (uint32)(arg0)
	r = cr != 0
	return
}

func (s *ArgInfo) GetDestroyIndex() (out_destroy_index uint32, r bool) {
	var arg0 C.uint
	cr := C.gi_arg_info_get_destroy_index(s.c(), &arg0)
	out_destroy_index = (uint32)(arg0)
	r = cr != 0
	return
}

func (s *ArgInfo) GetDirection() (r Direction) {
	cr := C.gi_arg_info_get_direction(s.c())
	r = Direction(cr)
	return
}

func (s *ArgInfo) GetOwnershipTransfer() (r Transfer) {
	cr := C.gi_arg_info_get_ownership_transfer(s.c())
	r = Transfer(cr)
	return
}

func (s *ArgInfo) GetScope() (r ScopeType) {
	cr := C.gi_arg_info_get_scope(s.c())
	r = ScopeType(cr)
	return
}

func (s *ArgInfo) GetTypeInfo() (r *TypeInfo) {
	cr := C.gi_arg_info_get_type_info(s.c())
	r = (*TypeInfo)(unsafe.Pointer(cr))
	return
}

func (s *ArgInfo) IsCallerAllocates() (r bool) {
	cr := C.gi_arg_info_is_caller_allocates(s.c())
	r = cr != 0
	return
}

func (s *ArgInfo) IsOptional() (r bool) {
	cr := C.gi_arg_info_is_optional(s.c())
	r = cr != 0
	return
}

func (s *ArgInfo) IsReturnValue() (r bool) {
	cr := C.gi_arg_info_is_return_value(s.c())
	r = cr != 0
	return
}

func (s *ArgInfo) IsSkip() (r bool) {
	cr := C.gi_arg_info_is_skip(s.c())
	r = cr != 0
	return
}

func (s *ArgInfo) LoadTypeInfo() (_type TypeInfo) {
	var arg0 C.GITypeInfo
	C.gi_arg_info_load_type_info(s.c(), &arg0)
	_type = *(*TypeInfo)(unsafe.Pointer(&arg0))
	return
}

func (s *ArgInfo) MayBeNull() (r bool) {
	cr := C.gi_arg_info_may_be_null(s.c())
	r = cr != 0
	return
}

type ArrayType int64

const (
	ArrayTypeC         ArrayType = 0
	ArrayTypeArray     ArrayType = 1
	ArrayTypePtrArray  ArrayType = 2
	ArrayTypeByteArray ArrayType = 3
)

var stringsArrayType = [...]string{
	0: "C",
	1: "Array",
	2: "PtrArray",
	3: "ByteArray",
}

func (v ArrayType) String() string {
	if v == 0 {
		return stringsArrayType[v]
	}

	var r []string
	if v&1 != 0 {
		r = append(r, stringsArrayType[1])
	}
	if v&2 != 0 {
		r = append(r, stringsArrayType[2])
	}
	if v&3 != 0 {
		r = append(r, stringsArrayType[3])
	}
	return strings.Join(r, ",")
}

type AttributeIter struct {
	_ structs.HostLayout
	_ [40]byte
}

func (s *AttributeIter) c() *C.GIAttributeIter {
	return (*C.GIAttributeIter)(unsafe.Pointer(s))
}

var TypeBaseInfo = g.Type[BaseInfo](C.gi_base_info_get_type())

type BaseInfo struct {
	_ structs.HostLayout
	g.TypeInstance
	_ [88]byte
}

func (obj *BaseInfo) c() *C.GIBaseInfo {
	return (*C.GIBaseInfo)(unsafe.Pointer(obj))
}

func (obj *BaseInfo) AsGIBaseInfo() *BaseInfo {
	return obj
}

func (s *BaseInfo) Clear() {
	C.gi_base_info_clear(unsafe.Pointer(s.c()))
	return
}

func (s *BaseInfo) Equal(info2 *BaseInfo) (r bool) {
	arg0 := (*C.GIBaseInfo)(unsafe.Pointer(info2))
	cr := C.gi_base_info_equal(s.c(), arg0)
	r = cr != 0
	return
}

func (s *BaseInfo) GetAttribute(name string) (r string) {
	arg0 := C.CString(name)
	defer C.free(unsafe.Pointer(arg0))
	cr := C.gi_base_info_get_attribute(s.c(), arg0)
	r = C.GoString(cr)
	return
}

func (s *BaseInfo) GetContainer() (r *BaseInfo) {
	cr := C.gi_base_info_get_container(s.c())
	r = (*BaseInfo)(unsafe.Pointer(cr))
	return
}

func (s *BaseInfo) GetName() (r string) {
	cr := C.gi_base_info_get_name(s.c())
	r = C.GoString(cr)
	return
}

func (s *BaseInfo) GetNamespace() (r string) {
	cr := C.gi_base_info_get_namespace(s.c())
	r = C.GoString(cr)
	return
}

func (s *BaseInfo) GetTypelib() (r *Typelib) {
	cr := C.gi_base_info_get_typelib(s.c())
	r = (*Typelib)(unsafe.Pointer(cr))
	return
}

func (s *BaseInfo) IsDeprecated() (r bool) {
	cr := C.gi_base_info_is_deprecated(s.c())
	r = cr != 0
	return
}

func (s *BaseInfo) IterateAttributes(iterator *AttributeIter) (name string, value string, r bool) {
	arg0 := (*C.GIAttributeIter)(unsafe.Pointer(iterator))
	var arg1 *C.char
	var arg2 *C.char
	cr := C.gi_base_info_iterate_attributes(s.c(), arg0, &arg1, &arg2)
	name = C.GoString(arg1)
	value = C.GoString(arg2)
	r = cr != 0
	return
}

func (s *BaseInfo) Ref() (r *BaseInfo) {
	cr := C.gi_base_info_ref(unsafe.Pointer(s.c()))
	r = (*BaseInfo)(unsafe.Pointer(cr))
	return
}

func (s *BaseInfo) Unref() {
	C.gi_base_info_unref(unsafe.Pointer(s.c()))
	return
}

type BaseInfoStack struct {
	_ structs.HostLayout
	_ [96]byte
}

func (s *BaseInfoStack) c() *C.GIBaseInfoStack {
	return (*C.GIBaseInfoStack)(unsafe.Pointer(s))
}

var TypeCallableInfo = g.Type[CallableInfo](C.gi_callable_info_get_type())

type CallableInfo struct {
	_ structs.HostLayout
	BaseInfo
}

func (obj *CallableInfo) c() *C.GICallableInfo {
	return (*C.GICallableInfo)(unsafe.Pointer(obj))
}

func (obj *CallableInfo) AsGICallableInfo() *CallableInfo {
	return obj
}

func (s *CallableInfo) CanThrowGerror() (r bool) {
	cr := C.gi_callable_info_can_throw_gerror(s.c())
	r = cr != 0
	return
}

func (s *CallableInfo) GetArg(n uint32) (r *ArgInfo) {
	arg0 := (C.uint)(n)
	cr := C.gi_callable_info_get_arg(s.c(), arg0)
	r = (*ArgInfo)(unsafe.Pointer(cr))
	return
}

func (s *CallableInfo) GetAsyncFunction() (r *CallableInfo) {
	cr := C.gi_callable_info_get_async_function(s.c())
	r = (*CallableInfo)(unsafe.Pointer(cr))
	return
}

func (s *CallableInfo) GetCallerOwns() (r Transfer) {
	cr := C.gi_callable_info_get_caller_owns(s.c())
	r = Transfer(cr)
	return
}

func (s *CallableInfo) GetFinishFunction() (r *CallableInfo) {
	cr := C.gi_callable_info_get_finish_function(s.c())
	r = (*CallableInfo)(unsafe.Pointer(cr))
	return
}

func (s *CallableInfo) GetInstanceOwnershipTransfer() (r Transfer) {
	cr := C.gi_callable_info_get_instance_ownership_transfer(s.c())
	r = Transfer(cr)
	return
}

func (s *CallableInfo) GetNArgs() (r uint32) {
	cr := C.gi_callable_info_get_n_args(s.c())
	r = (uint32)(cr)
	return
}

func (s *CallableInfo) GetReturnAttribute(name string) (r string) {
	arg0 := C.CString(name)
	defer C.free(unsafe.Pointer(arg0))
	cr := C.gi_callable_info_get_return_attribute(s.c(), arg0)
	r = C.GoString(cr)
	return
}

func (s *CallableInfo) GetReturnType() (r *TypeInfo) {
	cr := C.gi_callable_info_get_return_type(s.c())
	r = (*TypeInfo)(unsafe.Pointer(cr))
	return
}

func (s *CallableInfo) GetSyncFunction() (r *CallableInfo) {
	cr := C.gi_callable_info_get_sync_function(s.c())
	r = (*CallableInfo)(unsafe.Pointer(cr))
	return
}

func (s *CallableInfo) Invoke(function unsafe.Pointer, in_args []Argument, n_in_args uint64, out_args []Argument, n_out_args uint64) (return_value Argument, r bool, err error) {
	arg0 := (unsafe.Pointer)(function)
	arg1 := (*C.GIArgument)(unsafe.Pointer(unsafe.SliceData(in_args)))
	arg2 := (C.size_t)(n_in_args)
	arg3 := (*C.GIArgument)(unsafe.Pointer(unsafe.SliceData(out_args)))
	arg4 := (C.size_t)(n_out_args)
	var arg5 C.GIArgument
	var gerr *C.GError
	cr := C.gi_callable_info_invoke(s.c(), arg0, arg1, arg2, arg3, arg4, &arg5, &gerr)
	return_value = *(*Argument)(unsafe.Pointer(&arg5))
	r = cr != 0
	err = (*g.Error)(unsafe.Pointer(gerr))
	return
}

func (s *CallableInfo) IsAsync() (r bool) {
	cr := C.gi_callable_info_is_async(s.c())
	r = cr != 0
	return
}

func (s *CallableInfo) IsMethod() (r bool) {
	cr := C.gi_callable_info_is_method(s.c())
	r = cr != 0
	return
}

func (s *CallableInfo) IterateReturnAttributes(iterator *AttributeIter) (name string, value string, r bool) {
	arg0 := (*C.GIAttributeIter)(unsafe.Pointer(iterator))
	var arg1 *C.char
	var arg2 *C.char
	cr := C.gi_callable_info_iterate_return_attributes(s.c(), arg0, &arg1, &arg2)
	name = C.GoString(arg1)
	value = C.GoString(arg2)
	r = cr != 0
	return
}

func (s *CallableInfo) LoadArg(n uint32) (arg ArgInfo) {
	arg0 := (C.uint)(n)
	var arg1 C.GIArgInfo
	C.gi_callable_info_load_arg(s.c(), arg0, &arg1)
	arg = *(*ArgInfo)(unsafe.Pointer(&arg1))
	return
}

func (s *CallableInfo) LoadReturnType() (_type TypeInfo) {
	var arg0 C.GITypeInfo
	C.gi_callable_info_load_return_type(s.c(), &arg0)
	_type = *(*TypeInfo)(unsafe.Pointer(&arg0))
	return
}

func (s *CallableInfo) MayReturnNull() (r bool) {
	cr := C.gi_callable_info_may_return_null(s.c())
	r = cr != 0
	return
}

func (s *CallableInfo) SkipReturn() (r bool) {
	cr := C.gi_callable_info_skip_return(s.c())
	r = cr != 0
	return
}

var TypeCallbackInfo = g.Type[CallbackInfo](C.gi_callback_info_get_type())

type CallbackInfo struct {
	_ structs.HostLayout
	CallableInfo
}

func (obj *CallbackInfo) c() *C.GICallbackInfo {
	return (*C.GICallbackInfo)(unsafe.Pointer(obj))
}

func (obj *CallbackInfo) AsGICallbackInfo() *CallbackInfo {
	return obj
}

var TypeConstantInfo = g.Type[ConstantInfo](C.gi_constant_info_get_type())

type ConstantInfo struct {
	_ structs.HostLayout
	BaseInfo
}

func (obj *ConstantInfo) c() *C.GIConstantInfo {
	return (*C.GIConstantInfo)(unsafe.Pointer(obj))
}

func (obj *ConstantInfo) AsGIConstantInfo() *ConstantInfo {
	return obj
}

func (s *ConstantInfo) GetTypeInfo() (r *TypeInfo) {
	cr := C.gi_constant_info_get_type_info(s.c())
	r = (*TypeInfo)(unsafe.Pointer(cr))
	return
}

type Direction int64

const (
	DirectionIn    Direction = 0
	DirectionOut   Direction = 1
	DirectionInout Direction = 2
)

var stringsDirection = [...]string{
	0: "In",
	1: "Out",
	2: "Inout",
}

func (v Direction) String() string {
	if v == 0 {
		return stringsDirection[v]
	}

	var r []string
	if v&1 != 0 {
		r = append(r, stringsDirection[1])
	}
	if v&2 != 0 {
		r = append(r, stringsDirection[2])
	}
	return strings.Join(r, ",")
}

var TypeEnumInfo = g.Type[EnumInfo](C.gi_enum_info_get_type())

type EnumInfo struct {
	_ structs.HostLayout
	RegisteredTypeInfo
}

func (obj *EnumInfo) c() *C.GIEnumInfo {
	return (*C.GIEnumInfo)(unsafe.Pointer(obj))
}

func (obj *EnumInfo) AsGIEnumInfo() *EnumInfo {
	return obj
}

func (s *EnumInfo) GetErrorDomain() (r string) {
	cr := C.gi_enum_info_get_error_domain(s.c())
	r = C.GoString(cr)
	return
}

func (s *EnumInfo) GetMethod(n uint32) (r *FunctionInfo) {
	arg0 := (C.uint)(n)
	cr := C.gi_enum_info_get_method(s.c(), arg0)
	r = (*FunctionInfo)(unsafe.Pointer(cr))
	return
}

func (s *EnumInfo) GetNMethods() (r uint32) {
	cr := C.gi_enum_info_get_n_methods(s.c())
	r = (uint32)(cr)
	return
}

func (s *EnumInfo) GetNValues() (r uint32) {
	cr := C.gi_enum_info_get_n_values(s.c())
	r = (uint32)(cr)
	return
}

func (s *EnumInfo) GetStorageType() (r TypeTag) {
	cr := C.gi_enum_info_get_storage_type(s.c())
	r = TypeTag(cr)
	return
}

func (s *EnumInfo) GetValue(n uint32) (r *ValueInfo) {
	arg0 := (C.uint)(n)
	cr := C.gi_enum_info_get_value(s.c(), arg0)
	r = (*ValueInfo)(unsafe.Pointer(cr))
	return
}

var TypeFieldInfo = g.Type[FieldInfo](C.gi_field_info_get_type())

type FieldInfo struct {
	_ structs.HostLayout
	BaseInfo
}

func (obj *FieldInfo) c() *C.GIFieldInfo {
	return (*C.GIFieldInfo)(unsafe.Pointer(obj))
}

func (obj *FieldInfo) AsGIFieldInfo() *FieldInfo {
	return obj
}

func (s *FieldInfo) GetFlags() (r FieldInfoFlags) {
	cr := C.gi_field_info_get_flags(s.c())
	r = FieldInfoFlags(cr)
	return
}

func (s *FieldInfo) GetOffset() (r uint64) {
	cr := C.gi_field_info_get_offset(s.c())
	r = (uint64)(cr)
	return
}

func (s *FieldInfo) GetSize() (r uint64) {
	cr := C.gi_field_info_get_size(s.c())
	r = (uint64)(cr)
	return
}

func (s *FieldInfo) GetTypeInfo() (r *TypeInfo) {
	cr := C.gi_field_info_get_type_info(s.c())
	r = (*TypeInfo)(unsafe.Pointer(cr))
	return
}

type FieldInfoFlags int64

const (
	FieldInfoFlagsReadable FieldInfoFlags = 1
	FieldInfoFlagsWritable FieldInfoFlags = 2
)

var stringsFieldInfoFlags = [...]string{
	1: "Readable",
	2: "Writable",
}

func (v FieldInfoFlags) String() string {
	if v == 0 {
		return stringsFieldInfoFlags[v]
	}

	var r []string
	if v&1 != 0 {
		r = append(r, stringsFieldInfoFlags[1])
	}
	if v&2 != 0 {
		r = append(r, stringsFieldInfoFlags[2])
	}
	return strings.Join(r, ",")
}

var TypeFlagsInfo = g.Type[FlagsInfo](C.gi_flags_info_get_type())

type FlagsInfo struct {
	_ structs.HostLayout
	EnumInfo
}

func (obj *FlagsInfo) c() *C.GIFlagsInfo {
	return (*C.GIFlagsInfo)(unsafe.Pointer(obj))
}

func (obj *FlagsInfo) AsGIFlagsInfo() *FlagsInfo {
	return obj
}

var TypeFunctionInfo = g.Type[FunctionInfo](C.gi_function_info_get_type())

type FunctionInfo struct {
	_ structs.HostLayout
	CallableInfo
}

func (obj *FunctionInfo) c() *C.GIFunctionInfo {
	return (*C.GIFunctionInfo)(unsafe.Pointer(obj))
}

func (obj *FunctionInfo) AsGIFunctionInfo() *FunctionInfo {
	return obj
}

func (s *FunctionInfo) GetFlags() (r FunctionInfoFlags) {
	cr := C.gi_function_info_get_flags(s.c())
	r = FunctionInfoFlags(cr)
	return
}

func (s *FunctionInfo) GetProperty() (r *PropertyInfo) {
	cr := C.gi_function_info_get_property(s.c())
	r = (*PropertyInfo)(unsafe.Pointer(cr))
	return
}

func (s *FunctionInfo) GetSymbol() (r string) {
	cr := C.gi_function_info_get_symbol(s.c())
	r = C.GoString(cr)
	return
}

func (s *FunctionInfo) GetVfunc() (r *VFuncInfo) {
	cr := C.gi_function_info_get_vfunc(s.c())
	r = (*VFuncInfo)(unsafe.Pointer(cr))
	return
}

type FunctionInfoFlags int64

const (
	FunctionInfoFlagsIsMethod      FunctionInfoFlags = 1
	FunctionInfoFlagsIsConstructor FunctionInfoFlags = 2
	FunctionInfoFlagsIsGetter      FunctionInfoFlags = 4
	FunctionInfoFlagsIsSetter      FunctionInfoFlags = 8
	FunctionInfoFlagsWrapsVfunc    FunctionInfoFlags = 16
	FunctionInfoFlagsIsAsync       FunctionInfoFlags = 32
)

var stringsFunctionInfoFlags = [...]string{
	1:  "IsMethod",
	2:  "IsConstructor",
	4:  "IsGetter",
	8:  "IsSetter",
	16: "WrapsVfunc",
	32: "IsAsync",
}

func (v FunctionInfoFlags) String() string {
	if v == 0 {
		return stringsFunctionInfoFlags[v]
	}

	var r []string
	if v&1 != 0 {
		r = append(r, stringsFunctionInfoFlags[1])
	}
	if v&2 != 0 {
		r = append(r, stringsFunctionInfoFlags[2])
	}
	if v&4 != 0 {
		r = append(r, stringsFunctionInfoFlags[4])
	}
	if v&8 != 0 {
		r = append(r, stringsFunctionInfoFlags[8])
	}
	if v&16 != 0 {
		r = append(r, stringsFunctionInfoFlags[16])
	}
	if v&32 != 0 {
		r = append(r, stringsFunctionInfoFlags[32])
	}
	return strings.Join(r, ",")
}

var TypeInterfaceInfo = g.Type[InterfaceInfo](C.gi_interface_info_get_type())

type InterfaceInfo struct {
	_ structs.HostLayout
	RegisteredTypeInfo
}

func (obj *InterfaceInfo) c() *C.GIInterfaceInfo {
	return (*C.GIInterfaceInfo)(unsafe.Pointer(obj))
}

func (obj *InterfaceInfo) AsGIInterfaceInfo() *InterfaceInfo {
	return obj
}

func (s *InterfaceInfo) FindMethod(name string) (r *FunctionInfo) {
	arg0 := C.CString(name)
	defer C.free(unsafe.Pointer(arg0))
	cr := C.gi_interface_info_find_method(s.c(), arg0)
	r = (*FunctionInfo)(unsafe.Pointer(cr))
	return
}

func (s *InterfaceInfo) FindSignal(name string) (r *SignalInfo) {
	arg0 := C.CString(name)
	defer C.free(unsafe.Pointer(arg0))
	cr := C.gi_interface_info_find_signal(s.c(), arg0)
	r = (*SignalInfo)(unsafe.Pointer(cr))
	return
}

func (s *InterfaceInfo) FindVfunc(name string) (r *VFuncInfo) {
	arg0 := C.CString(name)
	defer C.free(unsafe.Pointer(arg0))
	cr := C.gi_interface_info_find_vfunc(s.c(), arg0)
	r = (*VFuncInfo)(unsafe.Pointer(cr))
	return
}

func (s *InterfaceInfo) GetConstant(n uint32) (r *ConstantInfo) {
	arg0 := (C.uint)(n)
	cr := C.gi_interface_info_get_constant(s.c(), arg0)
	r = (*ConstantInfo)(unsafe.Pointer(cr))
	return
}

func (s *InterfaceInfo) GetIfaceStruct() (r *StructInfo) {
	cr := C.gi_interface_info_get_iface_struct(s.c())
	r = (*StructInfo)(unsafe.Pointer(cr))
	return
}

func (s *InterfaceInfo) GetMethod(n uint32) (r *FunctionInfo) {
	arg0 := (C.uint)(n)
	cr := C.gi_interface_info_get_method(s.c(), arg0)
	r = (*FunctionInfo)(unsafe.Pointer(cr))
	return
}

func (s *InterfaceInfo) GetNConstants() (r uint32) {
	cr := C.gi_interface_info_get_n_constants(s.c())
	r = (uint32)(cr)
	return
}

func (s *InterfaceInfo) GetNMethods() (r uint32) {
	cr := C.gi_interface_info_get_n_methods(s.c())
	r = (uint32)(cr)
	return
}

func (s *InterfaceInfo) GetNPrerequisites() (r uint32) {
	cr := C.gi_interface_info_get_n_prerequisites(s.c())
	r = (uint32)(cr)
	return
}

func (s *InterfaceInfo) GetNProperties() (r uint32) {
	cr := C.gi_interface_info_get_n_properties(s.c())
	r = (uint32)(cr)
	return
}

func (s *InterfaceInfo) GetNSignals() (r uint32) {
	cr := C.gi_interface_info_get_n_signals(s.c())
	r = (uint32)(cr)
	return
}

func (s *InterfaceInfo) GetNVfuncs() (r uint32) {
	cr := C.gi_interface_info_get_n_vfuncs(s.c())
	r = (uint32)(cr)
	return
}

func (s *InterfaceInfo) GetPrerequisite(n uint32) (r *BaseInfo) {
	arg0 := (C.uint)(n)
	cr := C.gi_interface_info_get_prerequisite(s.c(), arg0)
	r = (*BaseInfo)(unsafe.Pointer(cr))
	return
}

func (s *InterfaceInfo) GetProperty(n uint32) (r *PropertyInfo) {
	arg0 := (C.uint)(n)
	cr := C.gi_interface_info_get_property(s.c(), arg0)
	r = (*PropertyInfo)(unsafe.Pointer(cr))
	return
}

func (s *InterfaceInfo) GetSignal(n uint32) (r *SignalInfo) {
	arg0 := (C.uint)(n)
	cr := C.gi_interface_info_get_signal(s.c(), arg0)
	r = (*SignalInfo)(unsafe.Pointer(cr))
	return
}

func (s *InterfaceInfo) GetVfunc(n uint32) (r *VFuncInfo) {
	arg0 := (C.uint)(n)
	cr := C.gi_interface_info_get_vfunc(s.c(), arg0)
	r = (*VFuncInfo)(unsafe.Pointer(cr))
	return
}

type InvokeError int64

const (
	InvokeErrorFailed           InvokeError = 0
	InvokeErrorSymbolNotFound   InvokeError = 1
	InvokeErrorArgumentMismatch InvokeError = 2
)

var stringsInvokeError = [...]string{
	0: "Failed",
	1: "SymbolNotFound",
	2: "ArgumentMismatch",
}

func (v InvokeError) String() string {
	if v == 0 {
		return stringsInvokeError[v]
	}

	var r []string
	if v&1 != 0 {
		r = append(r, stringsInvokeError[1])
	}
	if v&2 != 0 {
		r = append(r, stringsInvokeError[2])
	}
	return strings.Join(r, ",")
}

var TypeObjectInfo = g.Type[ObjectInfo](C.gi_object_info_get_type())

type ObjectInfo struct {
	_ structs.HostLayout
	RegisteredTypeInfo
}

func (obj *ObjectInfo) c() *C.GIObjectInfo {
	return (*C.GIObjectInfo)(unsafe.Pointer(obj))
}

func (obj *ObjectInfo) AsGIObjectInfo() *ObjectInfo {
	return obj
}

func (s *ObjectInfo) FindMethod(name string) (r *FunctionInfo) {
	arg0 := C.CString(name)
	defer C.free(unsafe.Pointer(arg0))
	cr := C.gi_object_info_find_method(s.c(), arg0)
	r = (*FunctionInfo)(unsafe.Pointer(cr))
	return
}

func (s *ObjectInfo) FindMethodUsingInterfaces(name string) (declarer *BaseInfo, r *FunctionInfo) {
	arg0 := C.CString(name)
	defer C.free(unsafe.Pointer(arg0))
	var arg1 *C.GIBaseInfo
	cr := C.gi_object_info_find_method_using_interfaces(s.c(), arg0, &arg1)
	declarer = (*BaseInfo)(unsafe.Pointer(arg1))
	r = (*FunctionInfo)(unsafe.Pointer(cr))
	return
}

func (s *ObjectInfo) FindSignal(name string) (r *SignalInfo) {
	arg0 := C.CString(name)
	defer C.free(unsafe.Pointer(arg0))
	cr := C.gi_object_info_find_signal(s.c(), arg0)
	r = (*SignalInfo)(unsafe.Pointer(cr))
	return
}

func (s *ObjectInfo) FindVfunc(name string) (r *VFuncInfo) {
	arg0 := C.CString(name)
	defer C.free(unsafe.Pointer(arg0))
	cr := C.gi_object_info_find_vfunc(s.c(), arg0)
	r = (*VFuncInfo)(unsafe.Pointer(cr))
	return
}

func (s *ObjectInfo) FindVfuncUsingInterfaces(name string) (declarer *BaseInfo, r *VFuncInfo) {
	arg0 := C.CString(name)
	defer C.free(unsafe.Pointer(arg0))
	var arg1 *C.GIBaseInfo
	cr := C.gi_object_info_find_vfunc_using_interfaces(s.c(), arg0, &arg1)
	declarer = (*BaseInfo)(unsafe.Pointer(arg1))
	r = (*VFuncInfo)(unsafe.Pointer(cr))
	return
}

func (s *ObjectInfo) GetAbstract() (r bool) {
	cr := C.gi_object_info_get_abstract(s.c())
	r = cr != 0
	return
}

func (s *ObjectInfo) GetClassStruct() (r *StructInfo) {
	cr := C.gi_object_info_get_class_struct(s.c())
	r = (*StructInfo)(unsafe.Pointer(cr))
	return
}

func (s *ObjectInfo) GetConstant(n uint32) (r *ConstantInfo) {
	arg0 := (C.uint)(n)
	cr := C.gi_object_info_get_constant(s.c(), arg0)
	r = (*ConstantInfo)(unsafe.Pointer(cr))
	return
}

func (s *ObjectInfo) GetField(n uint32) (r *FieldInfo) {
	arg0 := (C.uint)(n)
	cr := C.gi_object_info_get_field(s.c(), arg0)
	r = (*FieldInfo)(unsafe.Pointer(cr))
	return
}

func (s *ObjectInfo) GetFinal() (r bool) {
	cr := C.gi_object_info_get_final(s.c())
	r = cr != 0
	return
}

func (s *ObjectInfo) GetFundamental() (r bool) {
	cr := C.gi_object_info_get_fundamental(s.c())
	r = cr != 0
	return
}

func (s *ObjectInfo) GetGetValueFunctionName() (r string) {
	cr := C.gi_object_info_get_get_value_function_name(s.c())
	r = C.GoString(cr)
	return
}

func (s *ObjectInfo) GetInterface(n uint32) (r *InterfaceInfo) {
	arg0 := (C.uint)(n)
	cr := C.gi_object_info_get_interface(s.c(), arg0)
	r = (*InterfaceInfo)(unsafe.Pointer(cr))
	return
}

func (s *ObjectInfo) GetMethod(n uint32) (r *FunctionInfo) {
	arg0 := (C.uint)(n)
	cr := C.gi_object_info_get_method(s.c(), arg0)
	r = (*FunctionInfo)(unsafe.Pointer(cr))
	return
}

func (s *ObjectInfo) GetNConstants() (r uint32) {
	cr := C.gi_object_info_get_n_constants(s.c())
	r = (uint32)(cr)
	return
}

func (s *ObjectInfo) GetNFields() (r uint32) {
	cr := C.gi_object_info_get_n_fields(s.c())
	r = (uint32)(cr)
	return
}

func (s *ObjectInfo) GetNInterfaces() (r uint32) {
	cr := C.gi_object_info_get_n_interfaces(s.c())
	r = (uint32)(cr)
	return
}

func (s *ObjectInfo) GetNMethods() (r uint32) {
	cr := C.gi_object_info_get_n_methods(s.c())
	r = (uint32)(cr)
	return
}

func (s *ObjectInfo) GetNProperties() (r uint32) {
	cr := C.gi_object_info_get_n_properties(s.c())
	r = (uint32)(cr)
	return
}

func (s *ObjectInfo) GetNSignals() (r uint32) {
	cr := C.gi_object_info_get_n_signals(s.c())
	r = (uint32)(cr)
	return
}

func (s *ObjectInfo) GetNVfuncs() (r uint32) {
	cr := C.gi_object_info_get_n_vfuncs(s.c())
	r = (uint32)(cr)
	return
}

func (s *ObjectInfo) GetParent() (r *ObjectInfo) {
	cr := C.gi_object_info_get_parent(s.c())
	r = (*ObjectInfo)(unsafe.Pointer(cr))
	return
}

func (s *ObjectInfo) GetProperty(n uint32) (r *PropertyInfo) {
	arg0 := (C.uint)(n)
	cr := C.gi_object_info_get_property(s.c(), arg0)
	r = (*PropertyInfo)(unsafe.Pointer(cr))
	return
}

func (s *ObjectInfo) GetRefFunctionName() (r string) {
	cr := C.gi_object_info_get_ref_function_name(s.c())
	r = C.GoString(cr)
	return
}

func (s *ObjectInfo) GetSetValueFunctionName() (r string) {
	cr := C.gi_object_info_get_set_value_function_name(s.c())
	r = C.GoString(cr)
	return
}

func (s *ObjectInfo) GetSignal(n uint32) (r *SignalInfo) {
	arg0 := (C.uint)(n)
	cr := C.gi_object_info_get_signal(s.c(), arg0)
	r = (*SignalInfo)(unsafe.Pointer(cr))
	return
}

func (s *ObjectInfo) GetTypeInitFunctionName() (r string) {
	cr := C.gi_object_info_get_type_init_function_name(s.c())
	r = C.GoString(cr)
	return
}

func (s *ObjectInfo) GetTypeName() (r string) {
	cr := C.gi_object_info_get_type_name(s.c())
	r = C.GoString(cr)
	return
}

func (s *ObjectInfo) GetUnrefFunctionName() (r string) {
	cr := C.gi_object_info_get_unref_function_name(s.c())
	r = C.GoString(cr)
	return
}

func (s *ObjectInfo) GetVfunc(n uint32) (r *VFuncInfo) {
	arg0 := (C.uint)(n)
	cr := C.gi_object_info_get_vfunc(s.c(), arg0)
	r = (*VFuncInfo)(unsafe.Pointer(cr))
	return
}

var TypePropertyInfo = g.Type[PropertyInfo](C.gi_property_info_get_type())

type PropertyInfo struct {
	_ structs.HostLayout
	BaseInfo
}

func (obj *PropertyInfo) c() *C.GIPropertyInfo {
	return (*C.GIPropertyInfo)(unsafe.Pointer(obj))
}

func (obj *PropertyInfo) AsGIPropertyInfo() *PropertyInfo {
	return obj
}

func (s *PropertyInfo) GetFlags() (r g.ParamFlags) {
	cr := C.gi_property_info_get_flags(s.c())
	r = g.ParamFlags(cr)
	return
}

func (s *PropertyInfo) GetGetter() (r *FunctionInfo) {
	cr := C.gi_property_info_get_getter(s.c())
	r = (*FunctionInfo)(unsafe.Pointer(cr))
	return
}

func (s *PropertyInfo) GetOwnershipTransfer() (r Transfer) {
	cr := C.gi_property_info_get_ownership_transfer(s.c())
	r = Transfer(cr)
	return
}

func (s *PropertyInfo) GetSetter() (r *FunctionInfo) {
	cr := C.gi_property_info_get_setter(s.c())
	r = (*FunctionInfo)(unsafe.Pointer(cr))
	return
}

func (s *PropertyInfo) GetTypeInfo() (r *TypeInfo) {
	cr := C.gi_property_info_get_type_info(s.c())
	r = (*TypeInfo)(unsafe.Pointer(cr))
	return
}

var TypeRegisteredTypeInfo = g.Type[RegisteredTypeInfo](C.gi_registered_type_info_get_type())

type RegisteredTypeInfo struct {
	_ structs.HostLayout
	BaseInfo
}

func (obj *RegisteredTypeInfo) c() *C.GIRegisteredTypeInfo {
	return (*C.GIRegisteredTypeInfo)(unsafe.Pointer(obj))
}

func (obj *RegisteredTypeInfo) AsGIRegisteredTypeInfo() *RegisteredTypeInfo {
	return obj
}

func (s *RegisteredTypeInfo) GetGType() (r g.Type[g.TypeInstance]) {
	cr := C.gi_registered_type_info_get_g_type(s.c())
	r = (g.Type[g.TypeInstance])(cr)
	return
}

func (s *RegisteredTypeInfo) GetTypeInitFunctionName() (r string) {
	cr := C.gi_registered_type_info_get_type_init_function_name(s.c())
	r = C.GoString(cr)
	return
}

func (s *RegisteredTypeInfo) GetTypeName() (r string) {
	cr := C.gi_registered_type_info_get_type_name(s.c())
	r = C.GoString(cr)
	return
}

func (s *RegisteredTypeInfo) IsBoxed() (r bool) {
	cr := C.gi_registered_type_info_is_boxed(s.c())
	r = cr != 0
	return
}

var TypeRepository = g.Type[Repository](C.gi_repository_get_type())

type Repository struct {
	_ structs.HostLayout
	g.Object
	_ [96]byte
}

func (obj *Repository) c() *C.GIRepository {
	return (*C.GIRepository)(unsafe.Pointer(obj))
}

func (obj *Repository) AsGIRepository() *Repository {
	return obj
}

func RepositoryNew() (r *Repository) {
	cr := C.gi_repository_new()
	r = (*Repository)(unsafe.Pointer(cr))
	return
}

func RepositoryDump(input_filename string, output_filename string) (r bool, err error) {
	arg0 := C.CString(input_filename)
	defer C.free(unsafe.Pointer(arg0))
	arg1 := C.CString(output_filename)
	defer C.free(unsafe.Pointer(arg1))
	var gerr *C.GError
	cr := C.gi_repository_dump(arg0, arg1, &gerr)
	r = cr != 0
	err = (*g.Error)(unsafe.Pointer(gerr))
	return
}

func RepositoryErrorQuark() (r uint32) {
	cr := C.gi_repository_error_quark()
	r = (uint32)(cr)
	return
}

func RepositoryGetOptionGroup() (r *g.OptionGroup) {
	cr := C.gi_repository_get_option_group()
	r = (*g.OptionGroup)(unsafe.Pointer(cr))
	return
}

func (s *Repository) EnumerateVersions(namespace_ string) (n_versions_out uint64, r []string) {
	arg0 := C.CString(namespace_)
	defer C.free(unsafe.Pointer(arg0))
	var arg1 C.size_t
	C.gi_repository_enumerate_versions(s.c(), arg0, &arg1)
	n_versions_out = (uint64)(arg1)
	return
}

func (s *Repository) FindByErrorDomain(domain uint32) (r *EnumInfo) {
	arg0 := (C.uint)(domain)
	cr := C.gi_repository_find_by_error_domain(s.c(), arg0)
	r = (*EnumInfo)(unsafe.Pointer(cr))
	return
}

func (s *Repository) FindByGtype(gtype g.Type[g.TypeInstance]) (r *BaseInfo) {
	arg0 := (C.GType)(gtype)
	cr := C.gi_repository_find_by_gtype(s.c(), arg0)
	r = (*BaseInfo)(unsafe.Pointer(cr))
	return
}

func (s *Repository) FindByName(namespace_ string, name string) (r *BaseInfo) {
	arg0 := C.CString(namespace_)
	defer C.free(unsafe.Pointer(arg0))
	arg1 := C.CString(name)
	defer C.free(unsafe.Pointer(arg1))
	cr := C.gi_repository_find_by_name(s.c(), arg0, arg1)
	r = (*BaseInfo)(unsafe.Pointer(cr))
	return
}

func (s *Repository) GetCPrefix(namespace_ string) (r string) {
	arg0 := C.CString(namespace_)
	defer C.free(unsafe.Pointer(arg0))
	cr := C.gi_repository_get_c_prefix(s.c(), arg0)
	r = C.GoString(cr)
	return
}

func (s *Repository) GetDependencies(namespace_ string) (n_dependencies_out uint64, r []string) {
	arg0 := C.CString(namespace_)
	defer C.free(unsafe.Pointer(arg0))
	var arg1 C.size_t
	C.gi_repository_get_dependencies(s.c(), arg0, &arg1)
	n_dependencies_out = (uint64)(arg1)
	return
}

func (s *Repository) GetImmediateDependencies(namespace_ string) (n_dependencies_out uint64, r []string) {
	arg0 := C.CString(namespace_)
	defer C.free(unsafe.Pointer(arg0))
	var arg1 C.size_t
	C.gi_repository_get_immediate_dependencies(s.c(), arg0, &arg1)
	n_dependencies_out = (uint64)(arg1)
	return
}

func (s *Repository) GetInfo(namespace_ string, idx uint32) (r *BaseInfo) {
	arg0 := C.CString(namespace_)
	defer C.free(unsafe.Pointer(arg0))
	arg1 := (C.uint)(idx)
	cr := C.gi_repository_get_info(s.c(), arg0, arg1)
	r = (*BaseInfo)(unsafe.Pointer(cr))
	return
}

func (s *Repository) GetLibraryPath() (n_paths_out uint64, r []string) {
	var arg0 C.size_t
	C.gi_repository_get_library_path(s.c(), &arg0)
	n_paths_out = (uint64)(arg0)
	return
}

func (s *Repository) GetLoadedNamespaces() (n_namespaces_out uint64, r []string) {
	var arg0 C.size_t
	C.gi_repository_get_loaded_namespaces(s.c(), &arg0)
	n_namespaces_out = (uint64)(arg0)
	return
}

func (s *Repository) GetNInfos(namespace_ string) (r uint32) {
	arg0 := C.CString(namespace_)
	defer C.free(unsafe.Pointer(arg0))
	cr := C.gi_repository_get_n_infos(s.c(), arg0)
	r = (uint32)(cr)
	return
}

func (s *Repository) GetObjectGtypeInterfaces(gtype g.Type[g.TypeInstance]) (n_interfaces_out uint64, interfaces_out []*InterfaceInfo) {
	arg0 := (C.GType)(gtype)
	var arg1 C.size_t
	var arg2 **C.GIInterfaceInfo
	C.gi_repository_get_object_gtype_interfaces(s.c(), arg0, &arg1, &arg2)
	n_interfaces_out = (uint64)(arg1)
	return
}

func (s *Repository) GetSearchPath() (n_paths_out uint64, r []string) {
	var arg0 C.size_t
	C.gi_repository_get_search_path(s.c(), &arg0)
	n_paths_out = (uint64)(arg0)
	return
}

func (s *Repository) GetSharedLibraries(namespace_ string) (out_n_elements uint64, r []string) {
	arg0 := C.CString(namespace_)
	defer C.free(unsafe.Pointer(arg0))
	var arg1 C.size_t
	C.gi_repository_get_shared_libraries(s.c(), arg0, &arg1)
	out_n_elements = (uint64)(arg1)
	return
}

func (s *Repository) GetTypelibPath(namespace_ string) (r string) {
	arg0 := C.CString(namespace_)
	defer C.free(unsafe.Pointer(arg0))
	cr := C.gi_repository_get_typelib_path(s.c(), arg0)
	r = C.GoString(cr)
	return
}

func (s *Repository) GetVersion(namespace_ string) (r string) {
	arg0 := C.CString(namespace_)
	defer C.free(unsafe.Pointer(arg0))
	cr := C.gi_repository_get_version(s.c(), arg0)
	r = C.GoString(cr)
	return
}

func (s *Repository) IsRegistered(namespace_ string, version string) (r bool) {
	arg0 := C.CString(namespace_)
	defer C.free(unsafe.Pointer(arg0))
	arg1 := C.CString(version)
	defer C.free(unsafe.Pointer(arg1))
	cr := C.gi_repository_is_registered(s.c(), arg0, arg1)
	r = cr != 0
	return
}

func (s *Repository) LoadTypelib(typelib *Typelib, flags RepositoryLoadFlags) (r string, err error) {
	arg0 := (*C.GITypelib)(unsafe.Pointer(typelib))
	arg1 := C.GIRepositoryLoadFlags(flags)
	var gerr *C.GError
	cr := C.gi_repository_load_typelib(s.c(), arg0, arg1, &gerr)
	r = C.GoString(cr)
	err = (*g.Error)(unsafe.Pointer(gerr))
	return
}

func (s *Repository) PrependLibraryPath(directory string) {
	arg0 := C.CString(directory)
	defer C.free(unsafe.Pointer(arg0))
	C.gi_repository_prepend_library_path(s.c(), arg0)
	return
}

func (s *Repository) PrependSearchPath(directory string) {
	arg0 := C.CString(directory)
	defer C.free(unsafe.Pointer(arg0))
	C.gi_repository_prepend_search_path(s.c(), arg0)
	return
}

func (s *Repository) Require(namespace_ string, version string, flags RepositoryLoadFlags) (r *Typelib, err error) {
	arg0 := C.CString(namespace_)
	defer C.free(unsafe.Pointer(arg0))
	arg1 := C.CString(version)
	defer C.free(unsafe.Pointer(arg1))
	arg2 := C.GIRepositoryLoadFlags(flags)
	var gerr *C.GError
	cr := C.gi_repository_require(s.c(), arg0, arg1, arg2, &gerr)
	r = (*Typelib)(unsafe.Pointer(cr))
	return
}

func (s *Repository) RequirePrivate(typelib_dir string, namespace_ string, version string, flags RepositoryLoadFlags) (r *Typelib, err error) {
	arg0 := C.CString(typelib_dir)
	defer C.free(unsafe.Pointer(arg0))
	arg1 := C.CString(namespace_)
	defer C.free(unsafe.Pointer(arg1))
	arg2 := C.CString(version)
	defer C.free(unsafe.Pointer(arg2))
	arg3 := C.GIRepositoryLoadFlags(flags)
	var gerr *C.GError
	cr := C.gi_repository_require_private(s.c(), arg0, arg1, arg2, arg3, &gerr)
	r = (*Typelib)(unsafe.Pointer(cr))
	err = (*g.Error)(unsafe.Pointer(gerr))
	return
}

type RepositoryError int64

const (
	RepositoryErrorTypelibNotFound          RepositoryError = 0
	RepositoryErrorNamespaceMismatch        RepositoryError = 1
	RepositoryErrorNamespaceVersionConflict RepositoryError = 2
	RepositoryErrorLibraryNotFound          RepositoryError = 3
)

var stringsRepositoryError = [...]string{
	0: "TypelibNotFound",
	1: "NamespaceMismatch",
	2: "NamespaceVersionConflict",
	3: "LibraryNotFound",
}

func (v RepositoryError) String() string {
	if v == 0 {
		return stringsRepositoryError[v]
	}

	var r []string
	if v&1 != 0 {
		r = append(r, stringsRepositoryError[1])
	}
	if v&2 != 0 {
		r = append(r, stringsRepositoryError[2])
	}
	if v&3 != 0 {
		r = append(r, stringsRepositoryError[3])
	}
	return strings.Join(r, ",")
}

type RepositoryLoadFlags int64

const (
	RepositoryLoadFlagsNone RepositoryLoadFlags = 0
	RepositoryLoadFlagsLazy RepositoryLoadFlags = 1
)

var stringsRepositoryLoadFlags = [...]string{
	0: "None",
	1: "Lazy",
}

func (v RepositoryLoadFlags) String() string {
	if v == 0 {
		return stringsRepositoryLoadFlags[v]
	}

	var r []string
	if v&1 != 0 {
		r = append(r, stringsRepositoryLoadFlags[1])
	}
	return strings.Join(r, ",")
}

type ScopeType int64

const (
	ScopeTypeInvalid  ScopeType = 0
	ScopeTypeCall     ScopeType = 1
	ScopeTypeAsync    ScopeType = 2
	ScopeTypeNotified ScopeType = 3
	ScopeTypeForever  ScopeType = 4
)

var stringsScopeType = [...]string{
	0: "Invalid",
	1: "Call",
	2: "Async",
	3: "Notified",
	4: "Forever",
}

func (v ScopeType) String() string {
	if v == 0 {
		return stringsScopeType[v]
	}

	var r []string
	if v&1 != 0 {
		r = append(r, stringsScopeType[1])
	}
	if v&2 != 0 {
		r = append(r, stringsScopeType[2])
	}
	if v&3 != 0 {
		r = append(r, stringsScopeType[3])
	}
	if v&4 != 0 {
		r = append(r, stringsScopeType[4])
	}
	return strings.Join(r, ",")
}

var TypeSignalInfo = g.Type[SignalInfo](C.gi_signal_info_get_type())

type SignalInfo struct {
	_ structs.HostLayout
	CallableInfo
}

func (obj *SignalInfo) c() *C.GISignalInfo {
	return (*C.GISignalInfo)(unsafe.Pointer(obj))
}

func (obj *SignalInfo) AsGISignalInfo() *SignalInfo {
	return obj
}

func (s *SignalInfo) GetClassClosure() (r *VFuncInfo) {
	cr := C.gi_signal_info_get_class_closure(s.c())
	r = (*VFuncInfo)(unsafe.Pointer(cr))
	return
}

func (s *SignalInfo) GetFlags() (r g.SignalFlags) {
	cr := C.gi_signal_info_get_flags(s.c())
	r = g.SignalFlags(cr)
	return
}

func (s *SignalInfo) TrueStopsEmit() (r bool) {
	cr := C.gi_signal_info_true_stops_emit(s.c())
	r = cr != 0
	return
}

var TypeStructInfo = g.Type[StructInfo](C.gi_struct_info_get_type())

type StructInfo struct {
	_ structs.HostLayout
	RegisteredTypeInfo
}

func (obj *StructInfo) c() *C.GIStructInfo {
	return (*C.GIStructInfo)(unsafe.Pointer(obj))
}

func (obj *StructInfo) AsGIStructInfo() *StructInfo {
	return obj
}

func (s *StructInfo) FindField(name string) (r *FieldInfo) {
	arg0 := C.CString(name)
	defer C.free(unsafe.Pointer(arg0))
	cr := C.gi_struct_info_find_field(s.c(), arg0)
	r = (*FieldInfo)(unsafe.Pointer(cr))
	return
}

func (s *StructInfo) FindMethod(name string) (r *FunctionInfo) {
	arg0 := C.CString(name)
	defer C.free(unsafe.Pointer(arg0))
	cr := C.gi_struct_info_find_method(s.c(), arg0)
	r = (*FunctionInfo)(unsafe.Pointer(cr))
	return
}

func (s *StructInfo) GetAlignment() (r uint64) {
	cr := C.gi_struct_info_get_alignment(s.c())
	r = (uint64)(cr)
	return
}

func (s *StructInfo) GetCopyFunctionName() (r string) {
	cr := C.gi_struct_info_get_copy_function_name(s.c())
	r = C.GoString(cr)
	return
}

func (s *StructInfo) GetField(n uint32) (r *FieldInfo) {
	arg0 := (C.uint)(n)
	cr := C.gi_struct_info_get_field(s.c(), arg0)
	r = (*FieldInfo)(unsafe.Pointer(cr))
	return
}

func (s *StructInfo) GetFreeFunctionName() (r string) {
	cr := C.gi_struct_info_get_free_function_name(s.c())
	r = C.GoString(cr)
	return
}

func (s *StructInfo) GetMethod(n uint32) (r *FunctionInfo) {
	arg0 := (C.uint)(n)
	cr := C.gi_struct_info_get_method(s.c(), arg0)
	r = (*FunctionInfo)(unsafe.Pointer(cr))
	return
}

func (s *StructInfo) GetNFields() (r uint32) {
	cr := C.gi_struct_info_get_n_fields(s.c())
	r = (uint32)(cr)
	return
}

func (s *StructInfo) GetNMethods() (r uint32) {
	cr := C.gi_struct_info_get_n_methods(s.c())
	r = (uint32)(cr)
	return
}

func (s *StructInfo) GetSize() (r uint64) {
	cr := C.gi_struct_info_get_size(s.c())
	r = (uint64)(cr)
	return
}

func (s *StructInfo) IsForeign() (r bool) {
	cr := C.gi_struct_info_is_foreign(s.c())
	r = cr != 0
	return
}

func (s *StructInfo) IsGtypeStruct() (r bool) {
	cr := C.gi_struct_info_is_gtype_struct(s.c())
	r = cr != 0
	return
}

const TypeTagNTypes = "NOT IMPLEMENTED"

type Transfer int64

const (
	TransferNothing    Transfer = 0
	TransferContainer  Transfer = 1
	TransferEverything Transfer = 2
)

var stringsTransfer = [...]string{
	0: "Nothing",
	1: "Container",
	2: "Everything",
}

func (v Transfer) String() string {
	if v == 0 {
		return stringsTransfer[v]
	}

	var r []string
	if v&1 != 0 {
		r = append(r, stringsTransfer[1])
	}
	if v&2 != 0 {
		r = append(r, stringsTransfer[2])
	}
	return strings.Join(r, ",")
}

var TypeTypeInfo = g.Type[TypeInfo](C.gi_type_info_get_type())

type TypeInfo struct {
	_ structs.HostLayout
	BaseInfo
	_ [48]byte
}

func (obj *TypeInfo) c() *C.GITypeInfo {
	return (*C.GITypeInfo)(unsafe.Pointer(obj))
}

func (obj *TypeInfo) AsGITypeInfo() *TypeInfo {
	return obj
}

func (s *TypeInfo) ArgumentFromHashPointer(hash_pointer unsafe.Pointer) (arg Argument) {
	arg0 := (unsafe.Pointer)(hash_pointer)
	var arg1 C.GIArgument
	C.gi_type_info_argument_from_hash_pointer(s.c(), arg0, &arg1)
	arg = *(*Argument)(unsafe.Pointer(&arg1))
	return
}

func (s *TypeInfo) GetArrayFixedSize() (out_size uint64, r bool) {
	var arg0 C.size_t
	cr := C.gi_type_info_get_array_fixed_size(s.c(), &arg0)
	out_size = (uint64)(arg0)
	r = cr != 0
	return
}

func (s *TypeInfo) GetArrayLengthIndex() (out_length_index uint32, r bool) {
	var arg0 C.uint
	cr := C.gi_type_info_get_array_length_index(s.c(), &arg0)
	out_length_index = (uint32)(arg0)
	r = cr != 0
	return
}

func (s *TypeInfo) GetArrayType() (r ArrayType) {
	cr := C.gi_type_info_get_array_type(s.c())
	r = ArrayType(cr)
	return
}

func (s *TypeInfo) GetInterface() (r *BaseInfo) {
	cr := C.gi_type_info_get_interface(s.c())
	r = (*BaseInfo)(unsafe.Pointer(cr))
	return
}

func (s *TypeInfo) GetParamType(n uint32) (r *TypeInfo) {
	arg0 := (C.uint)(n)
	cr := C.gi_type_info_get_param_type(s.c(), arg0)
	r = (*TypeInfo)(unsafe.Pointer(cr))
	return
}

func (s *TypeInfo) GetStorageType() (r TypeTag) {
	cr := C.gi_type_info_get_storage_type(s.c())
	r = TypeTag(cr)
	return
}

func (s *TypeInfo) GetTag() (r TypeTag) {
	cr := C.gi_type_info_get_tag(s.c())
	r = TypeTag(cr)
	return
}

func (s *TypeInfo) HashPointerFromArgument(arg *Argument) {
	arg0 := (*C.GIArgument)(unsafe.Pointer(arg))
	C.gi_type_info_hash_pointer_from_argument(s.c(), arg0)
	return
}

func (s *TypeInfo) IsPointer() (r bool) {
	cr := C.gi_type_info_is_pointer(s.c())
	r = cr != 0
	return
}

func (s *TypeInfo) IsZeroTerminated() (r bool) {
	cr := C.gi_type_info_is_zero_terminated(s.c())
	r = cr != 0
	return
}

type TypeTag int64

const (
	TypeTagVoid      TypeTag = 0
	TypeTagBoolean   TypeTag = 1
	TypeTagInt8      TypeTag = 2
	TypeTagUint8     TypeTag = 3
	TypeTagInt16     TypeTag = 4
	TypeTagUint16    TypeTag = 5
	TypeTagInt32     TypeTag = 6
	TypeTagUint32    TypeTag = 7
	TypeTagInt64     TypeTag = 8
	TypeTagUint64    TypeTag = 9
	TypeTagFloat     TypeTag = 10
	TypeTagDouble    TypeTag = 11
	TypeTagGtype     TypeTag = 12
	TypeTagUtf8      TypeTag = 13
	TypeTagFilename  TypeTag = 14
	TypeTagArray     TypeTag = 15
	TypeTagInterface TypeTag = 16
	TypeTagGlist     TypeTag = 17
	TypeTagGslist    TypeTag = 18
	TypeTagGhash     TypeTag = 19
	TypeTagError     TypeTag = 20
	TypeTagUnichar   TypeTag = 21
)

var stringsTypeTag = [...]string{
	0:  "Void",
	1:  "Boolean",
	2:  "Int8",
	3:  "Uint8",
	4:  "Int16",
	5:  "Uint16",
	6:  "Int32",
	7:  "Uint32",
	8:  "Int64",
	9:  "Uint64",
	10: "Float",
	11: "Double",
	12: "Gtype",
	13: "Utf8",
	14: "Filename",
	15: "Array",
	16: "Interface",
	17: "Glist",
	18: "Gslist",
	19: "Ghash",
	20: "Error",
	21: "Unichar",
}

func (v TypeTag) String() string {
	if v == 0 {
		return stringsTypeTag[v]
	}

	var r []string
	if v&1 != 0 {
		r = append(r, stringsTypeTag[1])
	}
	if v&2 != 0 {
		r = append(r, stringsTypeTag[2])
	}
	if v&3 != 0 {
		r = append(r, stringsTypeTag[3])
	}
	if v&4 != 0 {
		r = append(r, stringsTypeTag[4])
	}
	if v&5 != 0 {
		r = append(r, stringsTypeTag[5])
	}
	if v&6 != 0 {
		r = append(r, stringsTypeTag[6])
	}
	if v&7 != 0 {
		r = append(r, stringsTypeTag[7])
	}
	if v&8 != 0 {
		r = append(r, stringsTypeTag[8])
	}
	if v&9 != 0 {
		r = append(r, stringsTypeTag[9])
	}
	if v&10 != 0 {
		r = append(r, stringsTypeTag[10])
	}
	if v&11 != 0 {
		r = append(r, stringsTypeTag[11])
	}
	if v&12 != 0 {
		r = append(r, stringsTypeTag[12])
	}
	if v&13 != 0 {
		r = append(r, stringsTypeTag[13])
	}
	if v&14 != 0 {
		r = append(r, stringsTypeTag[14])
	}
	if v&15 != 0 {
		r = append(r, stringsTypeTag[15])
	}
	if v&16 != 0 {
		r = append(r, stringsTypeTag[16])
	}
	if v&17 != 0 {
		r = append(r, stringsTypeTag[17])
	}
	if v&18 != 0 {
		r = append(r, stringsTypeTag[18])
	}
	if v&19 != 0 {
		r = append(r, stringsTypeTag[19])
	}
	if v&20 != 0 {
		r = append(r, stringsTypeTag[20])
	}
	if v&21 != 0 {
		r = append(r, stringsTypeTag[21])
	}
	return strings.Join(r, ",")
}

type Typelib struct {
	_ structs.HostLayout
	_ [0]byte
}

func (s *Typelib) c() *C.GITypelib {
	return (*C.GITypelib)(unsafe.Pointer(s))
}

func TypelibNewFromBytes(bytes *g.Bytes) (r *Typelib, err error) {
	arg0 := (*C.GBytes)(unsafe.Pointer(bytes))
	var gerr *C.GError
	cr := C.gi_typelib_new_from_bytes(arg0, &gerr)
	r = (*Typelib)(unsafe.Pointer(cr))
	err = (*g.Error)(unsafe.Pointer(gerr))
	return
}

func (s *Typelib) GetNamespace() (r string) {
	cr := C.gi_typelib_get_namespace(s.c())
	r = C.GoString(cr)
	return
}

func (s *Typelib) Ref() (r *Typelib) {
	cr := C.gi_typelib_ref(s.c())
	r = (*Typelib)(unsafe.Pointer(cr))
	return
}

func (s *Typelib) Symbol(symbol_name string) (symbol unsafe.Pointer, r bool) {
	arg0 := C.CString(symbol_name)
	defer C.free(unsafe.Pointer(arg0))
	var arg1 unsafe.Pointer
	cr := C.gi_typelib_symbol(s.c(), arg0, &arg1)
	symbol = (unsafe.Pointer)(arg1)
	r = cr != 0
	return
}

func (s *Typelib) Unref() {
	C.gi_typelib_unref(s.c())
	return
}

var TypeUnionInfo = g.Type[UnionInfo](C.gi_union_info_get_type())

type UnionInfo struct {
	_ structs.HostLayout
	RegisteredTypeInfo
}

func (obj *UnionInfo) c() *C.GIUnionInfo {
	return (*C.GIUnionInfo)(unsafe.Pointer(obj))
}

func (obj *UnionInfo) AsGIUnionInfo() *UnionInfo {
	return obj
}

func (s *UnionInfo) FindMethod(name string) (r *FunctionInfo) {
	arg0 := C.CString(name)
	defer C.free(unsafe.Pointer(arg0))
	cr := C.gi_union_info_find_method(s.c(), arg0)
	r = (*FunctionInfo)(unsafe.Pointer(cr))
	return
}

func (s *UnionInfo) GetAlignment() (r uint64) {
	cr := C.gi_union_info_get_alignment(s.c())
	r = (uint64)(cr)
	return
}

func (s *UnionInfo) GetCopyFunctionName() (r string) {
	cr := C.gi_union_info_get_copy_function_name(s.c())
	r = C.GoString(cr)
	return
}

func (s *UnionInfo) GetDiscriminator(n uint64) (r *ConstantInfo) {
	arg0 := (C.size_t)(n)
	cr := C.gi_union_info_get_discriminator(s.c(), arg0)
	r = (*ConstantInfo)(unsafe.Pointer(cr))
	return
}

func (s *UnionInfo) GetDiscriminatorOffset() (out_offset uint64, r bool) {
	var arg0 C.size_t
	cr := C.gi_union_info_get_discriminator_offset(s.c(), &arg0)
	out_offset = (uint64)(arg0)
	r = cr != 0
	return
}

func (s *UnionInfo) GetDiscriminatorType() (r *TypeInfo) {
	cr := C.gi_union_info_get_discriminator_type(s.c())
	r = (*TypeInfo)(unsafe.Pointer(cr))
	return
}

func (s *UnionInfo) GetField(n uint32) (r *FieldInfo) {
	arg0 := (C.uint)(n)
	cr := C.gi_union_info_get_field(s.c(), arg0)
	r = (*FieldInfo)(unsafe.Pointer(cr))
	return
}

func (s *UnionInfo) GetFreeFunctionName() (r string) {
	cr := C.gi_union_info_get_free_function_name(s.c())
	r = C.GoString(cr)
	return
}

func (s *UnionInfo) GetMethod(n uint32) (r *FunctionInfo) {
	arg0 := (C.uint)(n)
	cr := C.gi_union_info_get_method(s.c(), arg0)
	r = (*FunctionInfo)(unsafe.Pointer(cr))
	return
}

func (s *UnionInfo) GetNFields() (r uint32) {
	cr := C.gi_union_info_get_n_fields(s.c())
	r = (uint32)(cr)
	return
}

func (s *UnionInfo) GetNMethods() (r uint32) {
	cr := C.gi_union_info_get_n_methods(s.c())
	r = (uint32)(cr)
	return
}

func (s *UnionInfo) GetSize() (r uint64) {
	cr := C.gi_union_info_get_size(s.c())
	r = (uint64)(cr)
	return
}

func (s *UnionInfo) IsDiscriminated() (r bool) {
	cr := C.gi_union_info_is_discriminated(s.c())
	r = cr != 0
	return
}

var TypeUnresolvedInfo = g.Type[UnresolvedInfo](C.gi_unresolved_info_get_type())

type UnresolvedInfo struct {
	_ structs.HostLayout
	BaseInfo
	_ [16]byte
}

func (obj *UnresolvedInfo) c() *C.GIUnresolvedInfo {
	return (*C.GIUnresolvedInfo)(unsafe.Pointer(obj))
}

func (obj *UnresolvedInfo) AsGIUnresolvedInfo() *UnresolvedInfo {
	return obj
}

var TypeVFuncInfo = g.Type[VFuncInfo](C.gi_vfunc_info_get_type())

type VFuncInfo struct {
	_ structs.HostLayout
	CallableInfo
}

func (obj *VFuncInfo) c() *C.GIVFuncInfo {
	return (*C.GIVFuncInfo)(unsafe.Pointer(obj))
}

func (obj *VFuncInfo) AsGIVFuncInfo() *VFuncInfo {
	return obj
}

func (s *VFuncInfo) GetAddress(implementor_gtype g.Type[g.TypeInstance]) (err error) {
	arg0 := (C.GType)(implementor_gtype)
	var gerr *C.GError
	C.gi_vfunc_info_get_address(s.c(), arg0, &gerr)
	err = (*g.Error)(unsafe.Pointer(gerr))
	return
}

func (s *VFuncInfo) GetFlags() (r VFuncInfoFlags) {
	cr := C.gi_vfunc_info_get_flags(s.c())
	r = VFuncInfoFlags(cr)
	return
}

func (s *VFuncInfo) GetInvoker() (r *FunctionInfo) {
	cr := C.gi_vfunc_info_get_invoker(s.c())
	r = (*FunctionInfo)(unsafe.Pointer(cr))
	return
}

func (s *VFuncInfo) GetOffset() (r uint64) {
	cr := C.gi_vfunc_info_get_offset(s.c())
	r = (uint64)(cr)
	return
}

func (s *VFuncInfo) GetSignal() (r *SignalInfo) {
	cr := C.gi_vfunc_info_get_signal(s.c())
	r = (*SignalInfo)(unsafe.Pointer(cr))
	return
}

type VFuncInfoFlags int64

const (
	VFuncInfoFlagsChainUp     VFuncInfoFlags = 1
	VFuncInfoFlagsOverride    VFuncInfoFlags = 2
	VFuncInfoFlagsNotOverride VFuncInfoFlags = 4
)

var stringsVFuncInfoFlags = [...]string{
	1: "ChainUp",
	2: "Override",
	4: "NotOverride",
}

func (v VFuncInfoFlags) String() string {
	if v == 0 {
		return stringsVFuncInfoFlags[v]
	}

	var r []string
	if v&1 != 0 {
		r = append(r, stringsVFuncInfoFlags[1])
	}
	if v&2 != 0 {
		r = append(r, stringsVFuncInfoFlags[2])
	}
	if v&4 != 0 {
		r = append(r, stringsVFuncInfoFlags[4])
	}
	return strings.Join(r, ",")
}

var TypeValueInfo = g.Type[ValueInfo](C.gi_value_info_get_type())

type ValueInfo struct {
	_ structs.HostLayout
	BaseInfo
}

func (obj *ValueInfo) c() *C.GIValueInfo {
	return (*C.GIValueInfo)(unsafe.Pointer(obj))
}

func (obj *ValueInfo) AsGIValueInfo() *ValueInfo {
	return obj
}

func (s *ValueInfo) GetValue() (r int64) {
	cr := C.gi_value_info_get_value(s.c())
	r = (int64)(cr)
	return
}
