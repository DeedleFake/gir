// Code generated by girgen. DO NOT EDIT.

package gi

/*
#cgo pkg-config: girepository-2.0
#include <girepository/girepository.h>
*/
import "C"

import (
	"strings"
	"structs"
	"unsafe"

	"deedles.dev/gir/g"
)

var TypeArgInfo = g.ToType[ArgInfo](uint64(C.gi_arg_info_get_type()))

type ArgInfo struct {
	_ structs.HostLayout
	BaseInfo
	_ [48]byte
}

func (obj *ArgInfo) c() *C.GIArgInfo {
	return (*C.GIArgInfo)(unsafe.Pointer(obj))
}

func (obj *ArgInfo) AsGIArgInfo() *ArgInfo {
	return obj
}

type ArrayType int64

const (
	ArrayTypeC         ArrayType = 0
	ArrayTypeArray     ArrayType = 1
	ArrayTypePtrArray  ArrayType = 2
	ArrayTypeByteArray ArrayType = 3
)

var stringsArrayType = [...]string{
	0: "C",
	1: "Array",
	2: "PtrArray",
	3: "ByteArray",
}

func (v ArrayType) String() string {
	if v == 0 {
		return stringsArrayType[v]
	}

	var r []string
	if v&1 != 0 {
		r = append(r, stringsArrayType[1])
	}
	if v&2 != 0 {
		r = append(r, stringsArrayType[2])
	}
	if v&3 != 0 {
		r = append(r, stringsArrayType[3])
	}
	return strings.Join(r, ",")
}

type AttributeIter struct {
	_ structs.HostLayout
	_ [40]byte
}

func (s *AttributeIter) c() *C.GIAttributeIter {
	return (*C.GIAttributeIter)(unsafe.Pointer(s))
}

var TypeBaseInfo = g.ToType[BaseInfo](uint64(C.gi_base_info_get_type()))

type BaseInfo struct {
	_ structs.HostLayout
	g.TypeInstance
	_ [88]byte
}

func (obj *BaseInfo) c() *C.GIBaseInfo {
	return (*C.GIBaseInfo)(unsafe.Pointer(obj))
}

func (obj *BaseInfo) AsGIBaseInfo() *BaseInfo {
	return obj
}

type BaseInfoStack struct {
	_ structs.HostLayout
	_ [96]byte
}

func (s *BaseInfoStack) c() *C.GIBaseInfoStack {
	return (*C.GIBaseInfoStack)(unsafe.Pointer(s))
}

var TypeCallableInfo = g.ToType[CallableInfo](uint64(C.gi_callable_info_get_type()))

type CallableInfo struct {
	_ structs.HostLayout
	BaseInfo
}

func (obj *CallableInfo) c() *C.GICallableInfo {
	return (*C.GICallableInfo)(unsafe.Pointer(obj))
}

func (obj *CallableInfo) AsGICallableInfo() *CallableInfo {
	return obj
}

var TypeCallbackInfo = g.ToType[CallbackInfo](uint64(C.gi_callback_info_get_type()))

type CallbackInfo struct {
	_ structs.HostLayout
	CallableInfo
}

func (obj *CallbackInfo) c() *C.GICallbackInfo {
	return (*C.GICallbackInfo)(unsafe.Pointer(obj))
}

func (obj *CallbackInfo) AsGICallbackInfo() *CallbackInfo {
	return obj
}

var TypeConstantInfo = g.ToType[ConstantInfo](uint64(C.gi_constant_info_get_type()))

type ConstantInfo struct {
	_ structs.HostLayout
	BaseInfo
}

func (obj *ConstantInfo) c() *C.GIConstantInfo {
	return (*C.GIConstantInfo)(unsafe.Pointer(obj))
}

func (obj *ConstantInfo) AsGIConstantInfo() *ConstantInfo {
	return obj
}

type Direction int64

const (
	DirectionIn    Direction = 0
	DirectionOut   Direction = 1
	DirectionInout Direction = 2
)

var stringsDirection = [...]string{
	0: "In",
	1: "Out",
	2: "Inout",
}

func (v Direction) String() string {
	if v == 0 {
		return stringsDirection[v]
	}

	var r []string
	if v&1 != 0 {
		r = append(r, stringsDirection[1])
	}
	if v&2 != 0 {
		r = append(r, stringsDirection[2])
	}
	return strings.Join(r, ",")
}

var TypeEnumInfo = g.ToType[EnumInfo](uint64(C.gi_enum_info_get_type()))

type EnumInfo struct {
	_ structs.HostLayout
	RegisteredTypeInfo
}

func (obj *EnumInfo) c() *C.GIEnumInfo {
	return (*C.GIEnumInfo)(unsafe.Pointer(obj))
}

func (obj *EnumInfo) AsGIEnumInfo() *EnumInfo {
	return obj
}

var TypeFieldInfo = g.ToType[FieldInfo](uint64(C.gi_field_info_get_type()))

type FieldInfo struct {
	_ structs.HostLayout
	BaseInfo
}

func (obj *FieldInfo) c() *C.GIFieldInfo {
	return (*C.GIFieldInfo)(unsafe.Pointer(obj))
}

func (obj *FieldInfo) AsGIFieldInfo() *FieldInfo {
	return obj
}

type FieldInfoFlags int64

const (
	FieldInfoFlagsReadable FieldInfoFlags = 1
	FieldInfoFlagsWritable FieldInfoFlags = 2
)

var stringsFieldInfoFlags = [...]string{
	1: "Readable",
	2: "Writable",
}

func (v FieldInfoFlags) String() string {
	if v == 0 {
		return stringsFieldInfoFlags[v]
	}

	var r []string
	if v&1 != 0 {
		r = append(r, stringsFieldInfoFlags[1])
	}
	if v&2 != 0 {
		r = append(r, stringsFieldInfoFlags[2])
	}
	return strings.Join(r, ",")
}

var TypeFlagsInfo = g.ToType[FlagsInfo](uint64(C.gi_flags_info_get_type()))

type FlagsInfo struct {
	_ structs.HostLayout
	EnumInfo
}

func (obj *FlagsInfo) c() *C.GIFlagsInfo {
	return (*C.GIFlagsInfo)(unsafe.Pointer(obj))
}

func (obj *FlagsInfo) AsGIFlagsInfo() *FlagsInfo {
	return obj
}

var TypeFunctionInfo = g.ToType[FunctionInfo](uint64(C.gi_function_info_get_type()))

type FunctionInfo struct {
	_ structs.HostLayout
	CallableInfo
}

func (obj *FunctionInfo) c() *C.GIFunctionInfo {
	return (*C.GIFunctionInfo)(unsafe.Pointer(obj))
}

func (obj *FunctionInfo) AsGIFunctionInfo() *FunctionInfo {
	return obj
}

type FunctionInfoFlags int64

const (
	FunctionInfoFlagsIsMethod      FunctionInfoFlags = 1
	FunctionInfoFlagsIsConstructor FunctionInfoFlags = 2
	FunctionInfoFlagsIsGetter      FunctionInfoFlags = 4
	FunctionInfoFlagsIsSetter      FunctionInfoFlags = 8
	FunctionInfoFlagsWrapsVfunc    FunctionInfoFlags = 16
	FunctionInfoFlagsIsAsync       FunctionInfoFlags = 32
)

var stringsFunctionInfoFlags = [...]string{
	1:  "IsMethod",
	2:  "IsConstructor",
	4:  "IsGetter",
	8:  "IsSetter",
	16: "WrapsVfunc",
	32: "IsAsync",
}

func (v FunctionInfoFlags) String() string {
	if v == 0 {
		return stringsFunctionInfoFlags[v]
	}

	var r []string
	if v&1 != 0 {
		r = append(r, stringsFunctionInfoFlags[1])
	}
	if v&2 != 0 {
		r = append(r, stringsFunctionInfoFlags[2])
	}
	if v&4 != 0 {
		r = append(r, stringsFunctionInfoFlags[4])
	}
	if v&8 != 0 {
		r = append(r, stringsFunctionInfoFlags[8])
	}
	if v&16 != 0 {
		r = append(r, stringsFunctionInfoFlags[16])
	}
	if v&32 != 0 {
		r = append(r, stringsFunctionInfoFlags[32])
	}
	return strings.Join(r, ",")
}

var TypeInterfaceInfo = g.ToType[InterfaceInfo](uint64(C.gi_interface_info_get_type()))

type InterfaceInfo struct {
	_ structs.HostLayout
	RegisteredTypeInfo
}

func (obj *InterfaceInfo) c() *C.GIInterfaceInfo {
	return (*C.GIInterfaceInfo)(unsafe.Pointer(obj))
}

func (obj *InterfaceInfo) AsGIInterfaceInfo() *InterfaceInfo {
	return obj
}

type InvokeError int64

const (
	InvokeErrorFailed           InvokeError = 0
	InvokeErrorSymbolNotFound   InvokeError = 1
	InvokeErrorArgumentMismatch InvokeError = 2
)

var stringsInvokeError = [...]string{
	0: "Failed",
	1: "SymbolNotFound",
	2: "ArgumentMismatch",
}

func (v InvokeError) String() string {
	if v == 0 {
		return stringsInvokeError[v]
	}

	var r []string
	if v&1 != 0 {
		r = append(r, stringsInvokeError[1])
	}
	if v&2 != 0 {
		r = append(r, stringsInvokeError[2])
	}
	return strings.Join(r, ",")
}

var TypeObjectInfo = g.ToType[ObjectInfo](uint64(C.gi_object_info_get_type()))

type ObjectInfo struct {
	_ structs.HostLayout
	RegisteredTypeInfo
}

func (obj *ObjectInfo) c() *C.GIObjectInfo {
	return (*C.GIObjectInfo)(unsafe.Pointer(obj))
}

func (obj *ObjectInfo) AsGIObjectInfo() *ObjectInfo {
	return obj
}

var TypePropertyInfo = g.ToType[PropertyInfo](uint64(C.gi_property_info_get_type()))

type PropertyInfo struct {
	_ structs.HostLayout
	BaseInfo
}

func (obj *PropertyInfo) c() *C.GIPropertyInfo {
	return (*C.GIPropertyInfo)(unsafe.Pointer(obj))
}

func (obj *PropertyInfo) AsGIPropertyInfo() *PropertyInfo {
	return obj
}

var TypeRegisteredTypeInfo = g.ToType[RegisteredTypeInfo](uint64(C.gi_registered_type_info_get_type()))

type RegisteredTypeInfo struct {
	_ structs.HostLayout
	BaseInfo
}

func (obj *RegisteredTypeInfo) c() *C.GIRegisteredTypeInfo {
	return (*C.GIRegisteredTypeInfo)(unsafe.Pointer(obj))
}

func (obj *RegisteredTypeInfo) AsGIRegisteredTypeInfo() *RegisteredTypeInfo {
	return obj
}

var TypeRepository = g.ToType[Repository](uint64(C.gi_repository_get_type()))

type Repository struct {
	_ structs.HostLayout
	g.Object
	_ [96]byte
}

func (obj *Repository) c() *C.GIRepository {
	return (*C.GIRepository)(unsafe.Pointer(obj))
}

func (obj *Repository) AsGIRepository() *Repository {
	return obj
}

type RepositoryError int64

const (
	RepositoryErrorTypelibNotFound          RepositoryError = 0
	RepositoryErrorNamespaceMismatch        RepositoryError = 1
	RepositoryErrorNamespaceVersionConflict RepositoryError = 2
	RepositoryErrorLibraryNotFound          RepositoryError = 3
)

var stringsRepositoryError = [...]string{
	0: "TypelibNotFound",
	1: "NamespaceMismatch",
	2: "NamespaceVersionConflict",
	3: "LibraryNotFound",
}

func (v RepositoryError) String() string {
	if v == 0 {
		return stringsRepositoryError[v]
	}

	var r []string
	if v&1 != 0 {
		r = append(r, stringsRepositoryError[1])
	}
	if v&2 != 0 {
		r = append(r, stringsRepositoryError[2])
	}
	if v&3 != 0 {
		r = append(r, stringsRepositoryError[3])
	}
	return strings.Join(r, ",")
}

type RepositoryLoadFlags int64

const (
	RepositoryLoadFlagsNone RepositoryLoadFlags = 0
	RepositoryLoadFlagsLazy RepositoryLoadFlags = 1
)

var stringsRepositoryLoadFlags = [...]string{
	0: "None",
	1: "Lazy",
}

func (v RepositoryLoadFlags) String() string {
	if v == 0 {
		return stringsRepositoryLoadFlags[v]
	}

	var r []string
	if v&1 != 0 {
		r = append(r, stringsRepositoryLoadFlags[1])
	}
	return strings.Join(r, ",")
}

type ScopeType int64

const (
	ScopeTypeInvalid  ScopeType = 0
	ScopeTypeCall     ScopeType = 1
	ScopeTypeAsync    ScopeType = 2
	ScopeTypeNotified ScopeType = 3
	ScopeTypeForever  ScopeType = 4
)

var stringsScopeType = [...]string{
	0: "Invalid",
	1: "Call",
	2: "Async",
	3: "Notified",
	4: "Forever",
}

func (v ScopeType) String() string {
	if v == 0 {
		return stringsScopeType[v]
	}

	var r []string
	if v&1 != 0 {
		r = append(r, stringsScopeType[1])
	}
	if v&2 != 0 {
		r = append(r, stringsScopeType[2])
	}
	if v&3 != 0 {
		r = append(r, stringsScopeType[3])
	}
	if v&4 != 0 {
		r = append(r, stringsScopeType[4])
	}
	return strings.Join(r, ",")
}

var TypeSignalInfo = g.ToType[SignalInfo](uint64(C.gi_signal_info_get_type()))

type SignalInfo struct {
	_ structs.HostLayout
	CallableInfo
}

func (obj *SignalInfo) c() *C.GISignalInfo {
	return (*C.GISignalInfo)(unsafe.Pointer(obj))
}

func (obj *SignalInfo) AsGISignalInfo() *SignalInfo {
	return obj
}

var TypeStructInfo = g.ToType[StructInfo](uint64(C.gi_struct_info_get_type()))

type StructInfo struct {
	_ structs.HostLayout
	RegisteredTypeInfo
}

func (obj *StructInfo) c() *C.GIStructInfo {
	return (*C.GIStructInfo)(unsafe.Pointer(obj))
}

func (obj *StructInfo) AsGIStructInfo() *StructInfo {
	return obj
}

const TypeTagNTypes = "NOT IMPLEMENTED"

type Transfer int64

const (
	TransferNothing    Transfer = 0
	TransferContainer  Transfer = 1
	TransferEverything Transfer = 2
)

var stringsTransfer = [...]string{
	0: "Nothing",
	1: "Container",
	2: "Everything",
}

func (v Transfer) String() string {
	if v == 0 {
		return stringsTransfer[v]
	}

	var r []string
	if v&1 != 0 {
		r = append(r, stringsTransfer[1])
	}
	if v&2 != 0 {
		r = append(r, stringsTransfer[2])
	}
	return strings.Join(r, ",")
}

var TypeTypeInfo = g.ToType[TypeInfo](uint64(C.gi_type_info_get_type()))

type TypeInfo struct {
	_ structs.HostLayout
	BaseInfo
	_ [48]byte
}

func (obj *TypeInfo) c() *C.GITypeInfo {
	return (*C.GITypeInfo)(unsafe.Pointer(obj))
}

func (obj *TypeInfo) AsGITypeInfo() *TypeInfo {
	return obj
}

type TypeTag int64

const (
	TypeTagVoid      TypeTag = 0
	TypeTagBoolean   TypeTag = 1
	TypeTagInt8      TypeTag = 2
	TypeTagUint8     TypeTag = 3
	TypeTagInt16     TypeTag = 4
	TypeTagUint16    TypeTag = 5
	TypeTagInt32     TypeTag = 6
	TypeTagUint32    TypeTag = 7
	TypeTagInt64     TypeTag = 8
	TypeTagUint64    TypeTag = 9
	TypeTagFloat     TypeTag = 10
	TypeTagDouble    TypeTag = 11
	TypeTagGtype     TypeTag = 12
	TypeTagUtf8      TypeTag = 13
	TypeTagFilename  TypeTag = 14
	TypeTagArray     TypeTag = 15
	TypeTagInterface TypeTag = 16
	TypeTagGlist     TypeTag = 17
	TypeTagGslist    TypeTag = 18
	TypeTagGhash     TypeTag = 19
	TypeTagError     TypeTag = 20
	TypeTagUnichar   TypeTag = 21
)

var stringsTypeTag = [...]string{
	0:  "Void",
	1:  "Boolean",
	2:  "Int8",
	3:  "Uint8",
	4:  "Int16",
	5:  "Uint16",
	6:  "Int32",
	7:  "Uint32",
	8:  "Int64",
	9:  "Uint64",
	10: "Float",
	11: "Double",
	12: "Gtype",
	13: "Utf8",
	14: "Filename",
	15: "Array",
	16: "Interface",
	17: "Glist",
	18: "Gslist",
	19: "Ghash",
	20: "Error",
	21: "Unichar",
}

func (v TypeTag) String() string {
	if v == 0 {
		return stringsTypeTag[v]
	}

	var r []string
	if v&1 != 0 {
		r = append(r, stringsTypeTag[1])
	}
	if v&2 != 0 {
		r = append(r, stringsTypeTag[2])
	}
	if v&3 != 0 {
		r = append(r, stringsTypeTag[3])
	}
	if v&4 != 0 {
		r = append(r, stringsTypeTag[4])
	}
	if v&5 != 0 {
		r = append(r, stringsTypeTag[5])
	}
	if v&6 != 0 {
		r = append(r, stringsTypeTag[6])
	}
	if v&7 != 0 {
		r = append(r, stringsTypeTag[7])
	}
	if v&8 != 0 {
		r = append(r, stringsTypeTag[8])
	}
	if v&9 != 0 {
		r = append(r, stringsTypeTag[9])
	}
	if v&10 != 0 {
		r = append(r, stringsTypeTag[10])
	}
	if v&11 != 0 {
		r = append(r, stringsTypeTag[11])
	}
	if v&12 != 0 {
		r = append(r, stringsTypeTag[12])
	}
	if v&13 != 0 {
		r = append(r, stringsTypeTag[13])
	}
	if v&14 != 0 {
		r = append(r, stringsTypeTag[14])
	}
	if v&15 != 0 {
		r = append(r, stringsTypeTag[15])
	}
	if v&16 != 0 {
		r = append(r, stringsTypeTag[16])
	}
	if v&17 != 0 {
		r = append(r, stringsTypeTag[17])
	}
	if v&18 != 0 {
		r = append(r, stringsTypeTag[18])
	}
	if v&19 != 0 {
		r = append(r, stringsTypeTag[19])
	}
	if v&20 != 0 {
		r = append(r, stringsTypeTag[20])
	}
	if v&21 != 0 {
		r = append(r, stringsTypeTag[21])
	}
	return strings.Join(r, ",")
}

type Typelib struct {
	_ structs.HostLayout
	_ [0]byte
}

func (s *Typelib) c() *C.GITypelib {
	return (*C.GITypelib)(unsafe.Pointer(s))
}

func TypelibNewFromBytes(bytes *g.Bytes) (r *Typelib, err error) {
	arg0 := (*C.GBytes)(unsafe.Pointer(bytes))
	var gerr *C.GError
	cr := C.gi_typelib_new_from_bytes(arg0, &gerr)
	r = (*Typelib)(unsafe.Pointer(cr))
	err = (*g.Error)(unsafe.Pointer(gerr))
	return
}

func (s *Typelib) GetNamespace() (r string) {
	cr := C.gi_typelib_get_namespace(s.c())
	r = C.GoString(cr)
	return
}

func (s *Typelib) Ref() (r *Typelib) {
	cr := C.gi_typelib_ref(s.c())
	r = (*Typelib)(unsafe.Pointer(cr))
	return
}

func (s *Typelib) Symbol(symbol_name string) (symbol unsafe.Pointer, r bool) {
	arg0 := C.CString(symbol_name)
	defer C.free(unsafe.Pointer(arg0))
	arg1 := (unsafe.Pointer)(symbol)
	cr := C.gi_typelib_symbol(s.c(), arg0, &arg1)
	symbol = (unsafe.Pointer)(arg1)
	r = cr != 0
	return
}

func (s *Typelib) Unref() {
	C.gi_typelib_unref(s.c())
	return
}

var TypeUnionInfo = g.ToType[UnionInfo](uint64(C.gi_union_info_get_type()))

type UnionInfo struct {
	_ structs.HostLayout
	RegisteredTypeInfo
}

func (obj *UnionInfo) c() *C.GIUnionInfo {
	return (*C.GIUnionInfo)(unsafe.Pointer(obj))
}

func (obj *UnionInfo) AsGIUnionInfo() *UnionInfo {
	return obj
}

var TypeUnresolvedInfo = g.ToType[UnresolvedInfo](uint64(C.gi_unresolved_info_get_type()))

type UnresolvedInfo struct {
	_ structs.HostLayout
	BaseInfo
	_ [16]byte
}

func (obj *UnresolvedInfo) c() *C.GIUnresolvedInfo {
	return (*C.GIUnresolvedInfo)(unsafe.Pointer(obj))
}

func (obj *UnresolvedInfo) AsGIUnresolvedInfo() *UnresolvedInfo {
	return obj
}

var TypeVFuncInfo = g.ToType[VFuncInfo](uint64(C.gi_vfunc_info_get_type()))

type VFuncInfo struct {
	_ structs.HostLayout
	CallableInfo
}

func (obj *VFuncInfo) c() *C.GIVFuncInfo {
	return (*C.GIVFuncInfo)(unsafe.Pointer(obj))
}

func (obj *VFuncInfo) AsGIVFuncInfo() *VFuncInfo {
	return obj
}

type VFuncInfoFlags int64

const (
	VFuncInfoFlagsChainUp     VFuncInfoFlags = 1
	VFuncInfoFlagsOverride    VFuncInfoFlags = 2
	VFuncInfoFlagsNotOverride VFuncInfoFlags = 4
)

var stringsVFuncInfoFlags = [...]string{
	1: "ChainUp",
	2: "Override",
	4: "NotOverride",
}

func (v VFuncInfoFlags) String() string {
	if v == 0 {
		return stringsVFuncInfoFlags[v]
	}

	var r []string
	if v&1 != 0 {
		r = append(r, stringsVFuncInfoFlags[1])
	}
	if v&2 != 0 {
		r = append(r, stringsVFuncInfoFlags[2])
	}
	if v&4 != 0 {
		r = append(r, stringsVFuncInfoFlags[4])
	}
	return strings.Join(r, ",")
}

var TypeValueInfo = g.ToType[ValueInfo](uint64(C.gi_value_info_get_type()))

type ValueInfo struct {
	_ structs.HostLayout
	BaseInfo
}

func (obj *ValueInfo) c() *C.GIValueInfo {
	return (*C.GIValueInfo)(unsafe.Pointer(obj))
}

func (obj *ValueInfo) AsGIValueInfo() *ValueInfo {
	return obj
}
